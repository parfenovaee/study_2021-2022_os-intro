---
## Front matter
title: "Лабораторная работа 2"
subtitle: "Управление версиями"
author: "Парфенова Елизавета Евгеньевна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

– Изучить идеологию и применение средств контроля версий.

– Освоить умения по работе с git.

# Задание
– Создать базовую конфигурацию для работы с git.

– Создать ключ SSH.

– Создать ключ PGP.

– Настроить подписи git.

– Зарегистрироваться на Github.

– Создать локальный каталог для выполнения заданий по предмету.

# Теоретическое введение

**Системы контроля версий. Общие понятия**

*Системы контроля версий (Version Control System, VCS)* применяются при работе нескольких человек над одним проектом. Обычно основное дерево проекта хранится в локальном
или удалённом репозитории, к которому настроен доступ для участников проекта. При
внесении изменений в содержание проекта система контроля версий позволяет их
фиксировать, совмещать изменения, произведённые разными участниками проекта,
производить откат к любой более ранней версии проекта, если это требуется.

В классических системах контроля версий используется централизованная модель,
предполагающая наличие единого репозитория для хранения файлов. Выполнение большинства функций по управлению версиями осуществляется специальным сервером.
Участник проекта (пользователь) перед началом работы посредством определённых
команд получает нужную ему версию файлов. После внесения изменений, пользователь
размещает новую версию в хранилище. При этом предыдущие версии не удаляются
из центрального хранилища и к ним можно вернуться в любой момент. Сервер может
сохранять не полную версию изменённых файлов, а производить так называемую дельтакомпрессию — сохранять только изменения между последовательными версиями, что
позволяет уменьшить объём хранимых данных.

Системы контроля версий поддерживают возможность отслеживания и разрешения
конфликтов, которые могут возникнуть при работе нескольких человек над одним
файлом. Можно объединить (слить) изменения, сделанные разными участниками (автоматически или вручную), вручную выбрать нужную версию, отменить изменения вовсе
или заблокировать файлы для изменения. В зависимости от настроек блокировка не
позволяет другим пользователям получить рабочую копию или препятствует изменению
рабочей копии файла средствами файловой системы ОС, обеспечивая таким образом,
привилегированный доступ только одному пользователю, работающему с файлом.
Системы контроля версий также могут обеспечивать дополнительные, более гибкие
функциональные возможности. Например, они могут поддерживать работу с несколькими версиями одного файла, сохраняя общую историю изменений до точки ветвления
версий и собственные истории изменений каждой ветви. Кроме того, обычно доступна
информация о том, кто из участников, когда и какие изменения вносил. Обычно такого
рода информация хранится в журнале изменений, доступ к которому можно ограничить.

В отличие от классических, в распределённых системах контроля версий центральный
репозиторий не является обязательным.

Среди классических VCS наиболее известны CVS, Subversion, а среди распределённых — Git, Bazaar, Mercurial. Принципы их работы схожи, отличаются они в основном
синтаксисом используемых в работе команд.


**Основные команды git**

Наиболее часто используемые команды git:

– создание основного дерева репозитория:

***git init***

– получение обновлений (изменений) текущего дерева из центрального репозитория:

 ***git pull***

– отправка всех произведённых изменений локального дерева в центральный репозиторий:

***git push***

– просмотр списка изменённых файлов в текущей директории:

***git status***

– просмотр текущих изменения:

 ***git diff***


– добавить все изменённые и/или созданные файлы и/или каталоги:

***git add .***

– добавить конкретные изменённые и/или созданные файлы и/или каталоги:

***git add имена_файлов***

– удалить файл и/или каталог из индекса репозитория (при этом файл и/или каталог остаётся в локальной директории):

***git rm имена_файлов***

– сохранить все добавленные изменения и все изменённые файлы:

***git commit -am 'Описание коммита'***

– сохранить добавленные изменения с внесением комментария через встроенный редактор:

***git commit***

– создание новой ветки, базирующейся на текущей:

***git checkout -b имя_ветки***

– переключение на некоторую ветку(при переключении на ветку, которой ещё нет в локальном репозитории, она будет
создана и связана с удалённой):

***git checkout имя_ветки***

– отправка изменений конкретной ветки в центральный репозиторий:

***git push origin имя_ветки***

– слияние ветки с текущим деревом:

***git merge --no-ff имя_ветки***

– удаление локальной уже слитой с основным деревом ветки:

***git branch -d имя_ветки***

– принудительное удаление локальной ветки:

***git branch -D имя_ветки***

– удаление ветки с центрального репозитория:

***git push origin :имя_ветки***

**Работа с локальным репозиторием**

Создадим локальный репозиторий.

Сначала сделаем предварительную конфигурацию, указав имя и email владельца репозитория:

***git config --global user.name "Имя Фамилия"***

***git config --global user.email "work@mail"***

и настроив utf-8 в выводе сообщений git:

***git config --global quotepath false***

Для инициализации локального репозитория, расположенного, например, в каталоге ~/tutorial, необходимо ввести в командной строке:

***cd***

***mkdir tutorial***

***cd tutorial***

***git init***

После это в каталоге tutorial появится каталог .git, в котором будет храниться история изменений.

Создадим тестовый текстовый файл hello.txt и добавим его в локальный репозиторий:

***echo 'hello world' > hello.txt***
***git add hello.txt***
***git commit -am 'Новый файл'***

Воспользуемся командой status для просмотра изменений в рабочем каталоге, сделанных с момента последней ревизии:

***git status***

# Выполнение лабораторной работы

Вначале я перешла по ссылке https://github.com и создала учетную запись на github. 

![Рис. 1 Регистрация на GitHub](image/%D0%A0%D0%B8%D1%81%201.%20%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BD%D0%B0%20GitHub.png) Рис. 1 Регистрация на GitHub

После подтверждения кодом, который пришел на электронную почту, я настроила основные данные аккаунта. ![2](image/%D0%A0%D0%B8%D1%81.%202%20%20%D0%97%D0%B0%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B0%D0%BA%D0%BA%D0%B0%D1%83%D0%BD%D1%82%D0%B0.png) Рис. 2 Заполнение основных данных аккаунта

После я перешла в терминал и установку программного обеспечения. 

Вначале я  установила git-flow в Fedora Linux. Для этого я ввела три команды, так как ПО необходимо проводить вручную. 

Команды:

• ***wget --no-check-certificate -q https://raw.github.com/petervanderdoes /gitflow/develop/contrib/gitflow-installer.sh***

• ***chmod +x gitflow-installer.sh***

• ***sudo ./gitflow-installer.sh install stable***

![3](image/%D0%A0%D0%B8%D1%81.%203%20%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0%20git-flow.png) Рис. 3 Установка git-flow 

Далее я провела установку gh в Fedora Linux с помощью команды ***sudo dnf install gh.***

![4](image/%D0%A0%D0%B8%D1%81.%204%20%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0%20gh.png) Рис. 4 Установка gh


Следующим шагом я совершила базовую настройку git. 

С помощью двух команд я задала имя и email владельца репозитория:

• ***git config --global user.name ""***

• ***git config --global user.email "eliz.parfenowa2003@yandex.ru"***

Далее я настроила utf-8 в выводе сообщений git, используя команду ***git config --global core.quotepath false.***  После этого командой ***git config --global init.defaultBranch master*** я задала имя начальной ветки (master). Осталась настройка последних двух параметров. Первый параметр autocrlf я настроила командой git config - ***global core.autocrlf input***, а второй параметр safecrlf – командой git config - ***global core.safecrlf warn.***

![5](image/%D0%A0%D0%B8%D1%81.%205%20%D0%91%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5%20%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8%20git.png) Рис. 5 Базовые настройки git

Следующий шаг – создание ключа ssh. Вначале командой ***ssh-keygen -t rsa -b 4096*** я создаю ключ по алгоритму rsa размером 4096 бит, а после командой ***ssh-keygen -t ed25519*** – по алгоритму ed25519. 

![6](image/%D0%A0%D0%B8%D1%81.6.1%20%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%20ssh%20%D0%BF%D0%BE%20%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%83%20rsa.png)

![6](image/%D0%A0%D0%B8%D1%81.%206.2%20%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%20ssh%20%D0%BF%D0%BE%20%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%83%20ed25519.png) Рис.6 Создание ключа ssh

Следующим шагом я создала ключ pgp. Вначале необходимо было сгенерировать ключ с помощью команды gpg ***--full-generate-key***. Далее терминал предложил выбрать мне некоторые опции, и я выбрала их в соответствии с требованиями лабораторной работы. (тип RSA and RSA; размер 4096; не истекающий срок действия). Также я заполнила необходимую личную информацию (имя и адрес электронной почты). 

![7](image/%D0%A0%D0%B8%D1%81.%207%20%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%20pgp.png) Рис. 7 Создание ключа pgp

Далее созданный ключ я добавила в Github. Для того чтобы это сделать вначале было необходимо создать отпечаток приватного ключа. С помощью команды ***gpg --list-secret-keys --keyid-format LONG*** я вывела список ключей и нашла нужный 

![8](image/%D0%A0%D0%B8%D1%81.%208%20%D0%92%D1%8B%D0%B2%D0%BE%D0%B4%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0%20%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B9.png) Рис.8 Создание отпечатка приватного ключа


 Скопировала его и вставила в данную комнаду ***gpg --armor –export <PGP Fingerprint> | xclip -sel clip вместо <PGP Fingerprint>.*** Это нужно было для того, чтобы скопировать ключ в буфер обмена. 
 
 ![9](image/%D0%A0%D0%B8%D1%81.%209%20%D0%9A%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BD%D1%83%D0%B6%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%20%D0%B2%20%D0%B1%D1%83%D1%84%D0%B5%D1%80%20%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD%D0%B0.png) Рис. 9 Копирование ключа в буфер обмена
 
 После я зашла на Github и добавила ключ туда, во вкладку GPG Keys.         

 ![10](image/%D0%A0%D0%B8%D1%81.%2010%20%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%20%D0%BD%D0%B0%20Github.png) Рис. 10 Добавление ключа на GitHub

 Далее я настроила автоматические подписи коммитов git. Для этого используем введенный email. 

 ![11](image/%D0%A0%D0%B8%D1%81.%2011%20%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0%20%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85%20%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D0%B5%D0%B9%20%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2%20git.png) Рис. 11 Настройка автоматических подписей коммитов git

 После необходимо было настроить gh. Вначале с помощью команды ***gh auth login*** я авторизовалась. После ответила на вопросы, заданные в терминале. Он вывел код и запустила страницу браузера, где это необходимо было ввести. После ввода все завершилось успешно. 

 ![12](image/%D0%A0%D0%B8%D1%81.%2012%20%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0%20gh.png) Рис. 12 Настройка gh

Следующим шагом нужно было создать репозиторий курса на основе представленного в лабораторной работе шаблона. Создание репозитория представляло собой серию вот таких команд:

 • ***mkdir -p ~/work/study/2021-2022/"Операционные системы"***

• ***cd ~/work/study/2021-2022/"Операционные системы"***

 • ***gh repo create study_2021-2022_os-intro***

 • ***git clone –recursive git@github.com: parfenovaee/study_2021-2022_os-intro.git os-intro***

Однако, чтобы последняя команда прошла успешно, нужно выполнить дополнительные действия. Я загрузила ssh ключ на Github. Для этого я использовала команду ***cat ~/.ssh/id_rsa.pub | xclip -sel clip***, которая скопировала существующий ключ в буфер обмена. 

![13](image/%D0%A0%D0%B8%D1%81.%2013%20%D0%9A%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%20%D0%B2%20%D0%B1%D1%83%D1%84%D0%B5%D1%80%20%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD%D0%B0.png) Рис. 13 Копирование ключа в буфер обмена

После переходим на Github в уже знакомую у , где добавляли GPG ключ, и добавляем SSH ключ в нужное окно.  

![14](image/%D0%A0%D0%B8%D1%81.%2014%20%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%20%D0%BD%D0%B0%20Github.png) Рис.14 Добавление ключа в нужное окно

Теперь все команды по созданию репозитория курса могут быть выполнены успешно. 

![15](image/%D0%A0%D0%B8%D1%81.%2015%20%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F%20%D0%BA%D1%83%D1%80%D1%81%D0%B0%20%D0%BD%D0%B0%20%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B0.png)
![15](image/%D0%A0%D0%B8%D1%81.%2015.1%20%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F%20%D0%BA%D1%83%D1%80%D1%81%D0%B0%20%D0%BD%D0%B0%20%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B0.png) Рис. 15 Создание репозитория курса на основе шаблона

Последним шагом является настройка каталога курса. Начала я ее с команды ****cd ~/work/study/2021-2022/"Операционные системы"/os-intro***, которая позволила перейти в каталог. После я удалила лишние файлы командой ***rm package.json***. Создала необходимые каталоги, используя команду make ***COURSE=os-intro***. И отправила файлы на сервер следующими командами : 

• ***git add .***

• ***git commit -am 'feat(main): make course structure'*** (эта команда требует кодовой фразы, которую мы вводили ранее)

• ***git push***

![16](image/%D0%A0%D0%B8%D1%81.%2016.%201%20%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0%20%D0%BA%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3%D0%B0%20%D0%BA%D1%83%D1%80%D1%81%D0%B0.png)
![16](image/%D0%A0%D0%B8%D1%81.%2016.%202%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0%20%D0%BA%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3%D0%B0%20%D0%BA%D1%83%D1%80%D1%81%D0%B0.png) Рис.16 Настройка каталога курса

# Выводы

Мы изучили идеологию и применение средств контроля версий, а также освоили умения по работе с git.

# Контрольные вопросы

    1. Что такое системы контроля версий (VCS) и для решения каких задач они предназначаются?
Система контроля версий (VCS) - программное обеспечение для облегчения работы с изменяющейся информацией. Система управления версиями позволяет хранить несколько версий одного и того же документа, при необходимости возвращаться к более ранним версиям, определять, кто и когда сделал то или иное изменение, и многое другое.
Такие системы наиболее широко используются при разработке программного обеспечения для хранения исходных кодов разрабатываемой программы. Однако они могут с успехом применяться и в других областях, в которых ведётся работа с большим количеством непрерывно изменяющихся электронных документов.
    2. Объясните следующие понятия VCS и их отношения: хранилище, commit, история, рабочая копия.
Хранилище – репозиторий  - место хранения всех версий и служебной информации.
Commit - это команда для записи индексированных изменений в репозиторий.
История – место, где сохраняются все коммиты, по которым можно посмотреть данные о коммитах. 
Рабочая копия – текущее состояние файлов проекта, основанное на версии, загруженной из хранилища.
    3. Что представляют собой и чем отличаются централизованные и децентрализованные VCS? Приведите примеры VCS каждого вида

Централизованные системы – это системы, в которых одно основное хранилище всего проекта, и каждый пользователь копирует необходимые ему файлы, изменяет и вставляет обратно. Пример – Subversion.
Децентрализованные системы – система, в которой каждый пользователь имеет свой вариант репозитория и есть возможность добавлять и забирать изменения из репозиториев. Пример – Git.

    4. Опишите действия с VCS при единоличной работе с хранилищем.

В рабочей копии, которую исправляет человек, появляются правки, которые отправляются в хранилище на каждом из этапов. То есть в правки в рабочей копии появляются, только если человек делает их (отправляет их на сервер) и никак по-другому .

    5. Опишите порядок работы с общим хранилищем VCS.

Если хранилище общее, то в рабочую копию каждого, кто работает над проектом, приходят изменения, отправленные на сервер одним из команды. Рабочая правка каждого может изменяться вне зависимости от того, делает ли конкретный человек правки или нет.

    6. Каковы основные задачи, решаемые инструментальным средством git?

У Git две основных задачи: первая — хранить информацию обо всех изменениях в вашем коде, начиная с самой первой строчки, а вторая — обеспечение удобства командной работы над кодом.

    7. Назовите и дайте краткую характеристику командам git.

– создание основного дерева репозитория:  git init
 – получение обновлений (изменений) текущего дерева из центрального репозитория:  git pull 
– отправка всех произведённых изменений локального дерева в центральный репозиторий: git push 
– просмотр списка изменённых файлов в текущей директории:  git status
 – просмотр текущих изменения: git diff 
– сохранение текущих изменений: – добавить все изменённые и/или созданные файлы и/или каталоги:  git add .
 – добавить конкретные изменённые и/или созданные файлы и/или каталоги: git add 
– удалить файл и/или каталог из индекса репозитория (при этом файл и/или каталог остаётся в локальной директории):  git rm имена_файлов 
– сохранить все добавленные изменения и все изменённые файлы:  git commit -am 'Описание коммита' 
– сохранить добавленные изменения с внесением комментария через встроенный редактор: git commit 
– создание новой ветки, базирующейся на текущей: git checkout -b имя_ветки
 – переключение на некоторую ветку: git checkout имя_ветки (при переключении на ветку, которой ещё нет в локальном репозитории, она будет создана и связана с удалённой) 
– отправка изменений конкретной ветки в центральный репозиторий: 1 git push origin имя_ветки 
– слияние ветки с текущим деревом: 1 git merge --no-ff имя_ветки 
– удаление локальной уже слитой с основным деревом ветки:  git branch -d имя_ветки 
– принудительное удаление локальной ветки:  git branch -D имя_ветки 
– удаление ветки с центрального репозитория: git push origin :имя_ветки

    8. Приведите примеры использования при работе с локальным и удалённым репозиториями.

Работа с удаленным репозиторием: git remote – просмотр списка настроенных удаленных репозиториев.

Работа с локальным репозиторием: git status - выводит информацию обо всех изменениях, внесенных в дерево директорий проекта по сравнению с последним коммитом рабочей ветки

    9. Что такое и зачем могут быть нужны ветви (branches)?

Ветка (англ. branch) — это последовательность коммитов, в которой ведётся параллельная разработка какого-либо функционала. Ветки нужны, чтобы несколько программистов могли вести работу над одним и тем же проектом или даже файлом одновременно, при этом не мешая друг другу. Кроме того, ветки используются для тестирования экспериментальных функций: чтобы не повредить основному проекту, создается новая ветка специально для экспериментов.

    10. Как и зачем можно игнорировать некоторые файлы при commit?

Игнорируемые файлы — это, как правило, артефакты сборки и файлы, генерируемые машиной из исходных файлов в вашем репозитории, либо файлы, которые по какой-либо иной причине не должны попадать в коммиты.  В Git нет специальной команды для указания игнорируемых файлов: вместо этого необходимо вручную отредактировать файл . Временно игнорировать изменения в файле можно командой git update-index-assumeunchanged<file>

